---
mathjax: true
title: ç¬¬äºŒå±Šå¼ºç½‘æ¯å…¨å›½ç½‘ç»œå®‰å…¨æŒ‘æˆ˜èµ›
date: 2018-03-25 22:28:44
---

# MISC 

## Welcome

ä½¿ç”¨stegsolveæ‰“å¼€ï¼Œåœ¨Analyse->Stereogram Solver å¤„æ”¹å˜åç§»å³å¯ã€‚

![52198851836](1521988518362.png)

# Crypto

## streamgame1

***streamgame1.py***

```python
from flag import flag
assert flag.startswith("flag{")
assert flag.endswith("}")
assert len(flag)==25

def lfsr(R,mask):
    output = (R << 1) & 0xffffff
    i=(R&mask)&0xffffff
    lastbit=0
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)


R=int(flag[5:-1],2)
mask    =   0b1010011000100011100

f=open("key","ab")
for i in range(12):
    tmp=0
    for j in range(8):
        (R,out)=lfsr(R,mask)
        tmp=(tmp << 1)^out
    f.write(chr(tmp))
f.close()
```

***solution***

```python
def crack(key):
    for k in range(0,2**19):
        R=k
        for i in range(12):
            tmp,flag=0,1
            for j in range(8):
                (R,out)=lfsr(R,mask)
                tmp=(tmp << 1)^out
            if(chr(tmp)!=key[i]):
                flag=0
                break
        if flag:
            print "flag{%s}"%bin(k)[2:]

crack(open('key','rb').read())
# flag{1110101100001101011}
```

## streamgame2

***streamgame2.py***

```python
from flag import flag
assert flag.startswith("flag{")
assert flag.endswith("}")
assert len(flag)==27

def lfsr(R,mask):
    output = (R << 1) & 0xffffff
    i=(R&mask)&0xffffff
    lastbit=0
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)

R=int(flag[5:-1],2)
mask=0x100002

f=open("key","ab")
for i in range(12):
    tmp=0
    for j in range(8):
        (R,out)=lfsr(R,mask)
        tmp=(tmp << 1)^out
    f.write(chr(tmp))
f.close()
```

***solution***

```python
def crack(key):
    for k in range(0,2**21):
        R=k
        for i in range(12):
            tmp=0
            flag=1
            for j in range(8):
                (R,out)=lfsr(R,mask)
                tmp=(tmp << 1)^out
            if(chr(tmp)!=key[i]):
                flag=0
                break
        if flag:
            print "flag{%s}"%bin(k)[2:]
crack(open('key','rb').read())
# flag{110111100101001101001}
```

## streamgame3

```python
from flag import flag
assert flag.startswith("flag{")
assert flag.endswith("}")
assert len(flag)==24

def lfsr(R,mask):
    output = (R << 1) & 0xffffff
    i = (R&mask)&0xffffff
    
    lastbit=0
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)

def single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask):

    (R1_NEW,x1)=lfsr(R1,R1_mask)
    (R2_NEW,x2)=lfsr(R2,R2_mask)
    (R3_NEW,x3)=lfsr(R3,R3_mask)

    return (R1_NEW, R2_NEW, R3_NEW, (x1*x2)^((x2^1)*x3) )

R1=int(flag[5:11],16)
R2=int(flag[11:17],16)
R3=int(flag[17:23],16)

assert len(bin(R1)[2:])==17
assert len(bin(R2)[2:])==19
assert len(bin(R3)[2:])==21

R1_mask=0x10020
R2_mask=0x4100c
R3_mask=0x100002


for fi in range(1024):
    print fi
    tmp1mb=""

    for i in range(1024):
        tmp1kb=""

        for j in range(1024):
            tmp=0

            for k in range(8):
                (R1,R2,R3,out)=single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask)
                tmp = (tmp << 1) ^ out
            tmp1kb+=chr(tmp)

        tmp1mb+=tmp1kb

    f = open("./output/" + str(fi), "ab")
    f.write(tmp1mb)
    f.close()
```

**solution**

å¦‚æœä¸¤ä¸ªéšæœºäºŒè¿›åˆ¶ä¸²ä¸ç›¸å…³ï¼Œé‚£ä¹ˆå°†å®ƒä»¬é€ä½æ¯”å¯¹ï¼Œæœ‰1/2çš„æ¦‚ç‡ç›¸ç­‰ï¼Œå¦‚æœæ˜¯ä¸‰è¿›åˆ¶ä¸²ï¼Œåˆ™æ¦‚ç‡ä¸º1/3ï¼Œä»¥æ­¤ç±»æ¨ã€‚å†™ä¸ªå°è„šæœ¬éªŒè¯ä¸€ä¸‹ï¼š

![1525350802411](1525350802411.png)

ç›¸åçš„ï¼Œå¦‚æœä¸¤ä¸ªéšæœºäºŒè¿›åˆ¶ä¸²ä¹‹é—´çš„å­˜åœ¨å…³è”ï¼Œé‚£ä¹ˆæ¦‚ç‡å°±ä¸ä¼šæ˜¯1/2äº†ã€‚

å¯¹äº` x1,x2,x3âˆˆ{0,1}` è€ƒè™‘é€»è¾‘è¿ç®—  `out=(x1*x2)^((x2^1)*x3)`  ï¼Œ

è‹¥`x2=0` ï¼Œåˆ™`out=x3` ï¼Œè‹¥`x2=1` åˆ™`out=x1`  ã€‚

é‚£ä¹ˆ`p(out=x3) = p(out=x3|x2=0) * p(x2=0)+ p(out=x3|x2=1) * p(x2=1)=(1+1/2) * 1/2 = 3/4 != 1/2 `  ï¼Œ

å¯¹äºx1åŒç†æœ‰`p(out=x1)=3/4 != 1/2` ã€‚

è¿™ä¸ªé¢˜ç›®ç›´è§‚çš„æƒ³æ³•å’Œå‰ä¸¤é¢˜ä¸€æ ·ï¼Œéå†R1ï¼ŒR2ï¼ŒR3ä¸‰ä¸ªå¯„å­˜å™¨æ‰€æœ‰å¯èƒ½çš„åˆå§‹çŠ¶æ€ï¼Œä½†å› ä¸ºå¯èƒ½æ€§è¿‡å¤šåœ¨è®¡ç®—ä¸Šæ˜¯ä¸å¯è¡Œçš„ã€‚ä¸Šé¢æåˆ°çš„è¿™ç§ç›¸å…³æ€§æä¾›äº†ä¸€ç§å„ä¸ªå‡»ç ´çš„æ€è·¯ï¼šéå†R1çš„æ‰€æœ‰å¯èƒ½ï¼Œè®¡ç®—å…¶ä¸outçš„ç›¸å…³æ€§ï¼Œé€¼è¿‘3/4çš„å°±å¯èƒ½æ˜¯å…¶åˆå§‹çŠ¶æ€ï¼Œè¶Šé€¼è¿‘å¯èƒ½æ€§è¶Šå¤§ï¼Œå¯¹R3åŒç†ã€‚

è¿™ç§åŸºäºç›¸å…³æ€§çš„æ”»å‡»ç§°ä¸ºç›¸å…³æ”»å‡»ï¼ˆcorrelation attackï¼‰ï¼Œå…¶åˆ†è€Œæ²»ä¹‹çš„æŠ€å·§å¯ä»¥é™ä½çˆ†ç ´å¤æ‚åº¦ï¼Œæ¯”ç›¸å…³æ”»å‡»å¤æ‚åº¦æ›´ä½çš„éƒ½å¯ä»¥ç§°ä¸ºå¿«é€Ÿç›¸å…³æ”»å‡»ï¼ˆä¹Ÿæœ‰ä¸€äº›ç»å…¸çš„æ‰‹æ³•ï¼Œä¸è¿‡ç›®å‰è¿˜æ²¡å¾ˆç†è§£ï¼‰ã€‚

æœ¬é¢˜é‡‡ç”¨ç›¸å…³æ”»å‡»å°±å¯ä»¥åœ¨å¯æ¥å—æ—¶é—´å†…å¾—åˆ°R1ï¼ŒR3çš„åˆå§‹çŠ¶æ€ã€‚

åˆå§‹çŠ¶æ€çš„å¯é€‰ç©ºé—´è¶Šå¤§ï¼Œå°±éœ€è¦è¶Šé•¿çš„ç»“æœåºåˆ—æ¥åˆ¤å®šã€‚R1ï¼ŒR3åˆ†åˆ«å¤§æ¦‚7å­—èŠ‚å’Œ17å­—èŠ‚å°±è¶³å¤Ÿäº†ã€‚

![1525353329312](1525353329312.png)

ç„¶åçˆ†ç ´R2å°±ä¸éš¾äº†ã€‚

![1525356729608](1525356729608.png)

å…¨éƒ¨ä»£ç å¦‚ä¸‹ï¼š

```python
import time
cipher=''.join([bin(ord(i))[2:].zfill(8) for i in open("output/0","rb").read()])
R1_mask=0x10020 ; R2_mask=0x4100c ; R3_mask=0x100002
R1_range=xrange(2**16,2**17)
R2_range=xrange(2**18,2**19)
R3_range=xrange(2**20,2**21)

def lfsr(R,mask):
    output = (R << 1) & 0xffffff
    i=(R&mask)&0xffffff
    lastbit=0
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)

def single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask):
    (R1_NEW,x1)=lfsr(R1,R1_mask)
    (R2_NEW,x2)=lfsr(R2,R2_mask)
    (R3_NEW,x3)=lfsr(R3,R3_mask)
    return (R1_NEW, R2_NEW, R3_NEW, (x1*x2)^((x2^1)*x3) )

def calcRelation(a,b):
    assert len(a)==len(b)
    cnt=0.0
    for i,j in zip(a,b):
        cnt+=(i==j)
    return cnt/len(a)

def get_most_related(R_range,R_mask,cmp_length):
    real_R,relation=0,0
    for i in R_range:
        R,tmp=i,""
        for j in xrange(cmp_length*8):
            R,out=lfsr(R,R_mask)
            tmp+=str(out)
        r=calcRelation(cipher[:cmp_length*8],tmp)
        if r>relation:
            relation=r 
            real_R=i
    return (real_R,relation)

def bruteR13():
    R1,r=get_most_related(R1_range,R1_mask,7)
    R3,r=get_most_related(R3_range,R3_mask,17)
    return (R1,R3)

def brute():
    R1_,R3_=bruteR13()
    # R1_,R3_=0x1b9cb,0x16b2f3
    print "R1=%s,R3=%s"%(R1_,R3_)
    print time.asctime()
    for i in R2_range:
        R1,R2,R3=R1_,i,R3_
        res=''
        for j in range(40):
            (R1,R2,R3,out)=single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask)
            res+=str(out)
        if cipher[:len(res)]==res:
            print 'flag{'+''.join(map(lambda x:hex(x)[2:],(R1_,i,R3_)))+'}'

print time.asctime()
brute()
print time.asctime()

# Thu May 03 21:56:46 2018
# R1=113099,R3=1487603
# Thu May 03 22:01:41 2018
# flag{1b9cb5979c16b2f3}
# Thu May 03 22:02:41 2018
# [Finished in 357.3s]
```

å‚è€ƒï¼š[http://blog.leanote.com/post/xp0intjnu@gmail.com/66c91498d13b](http://blog.leanote.com/post/xp0intjnu@gmail.com/66c91498d13b) 

## streamgame4

***streamgame4.py***

```python
from flag import flag
assert flag.startswith("flag{")
assert flag.endswith("}")
assert len(flag)==27

def nlfsr(R,mask):
    output = (R << 1) & 0xffffff
    i=(R&mask)&0xffffff
    lastbit=0
    changesign=True
    while i!=0:
        if changesign:
            lastbit &= (i & 1)
            changesign=False
        else:
            lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)

R=int(flag[5:-1],2)
mask=0b110110011011001101110

f=open("key","ab")
for i in range(1024*1024):
    tmp=0
    for j in range(8):
        (R,out)=nlfsr(R,mask)
        tmp=(tmp << 1)^out
    f.write(chr(tmp))
f.close()
```

***solution***

```python
def crack(key):
    for maybe in range(2**21,0,-1):
        flag=0
        R=maybe
        for index in xrange(len(key)):
            tmp=0
            for j in range(8):
                (R,out)=nlfsr(R,mask)
                tmp=(tmp<<1)^out
            if chr(tmp)!=key[index]:
                flag=1
                break
        if not flag:
            print "flag{%s}"%bin(maybe)[2:]

crack(open("key",'r').read())
#flag{100100111010101101011}
```

## nextrsa

> nc 39.107.33.90 9999

è¿™æ˜¯ä¸€ä¸ªRSAç›¸å…³å®‰å…¨é—®é¢˜çš„åˆé›†ï¼Œæ˜¯ä¸ªå¾ˆæœ‰æ„æ€å€¼å¾—ä¸€åšçš„é¢˜ç›®ã€‚

é¢˜ç›®æºç å·²å…¬å¼€åœ¨GitHubï¼šhttps://github.com/fpbibi/nextrsa

å¯å‚è€ƒä»¥ä¸‹é“¾æ¥ï¼š

- http://www.cnblogs.com/WangAoBo/p/8654120.html
- https://www.anquanke.com/post/id/84632
- https://err0rzz.github.io/2017/11/14/CTF%E4%B8%ADRSA%E5%A5%97%E8%B7%AF/
- https://bbs.ichunqiu.com/thread-36705-1-1.html

# Web

## Webç­¾åˆ°

### The Fisrt Easy Md5 Challenge

```php+HTML
if($_POST['param1']!=$_POST['param2'] && md5($_POST['param1'])==md5($_POST['param2'])){
			die("success!");
		}
```

å¯ç”¨PHPå¼±ç±»å‹æˆ–è€…æ•°ç»„ç»•è¿‡ã€‚

post `param1=QNKCDZO&param2=240610708` æˆ–è€… `param1[]=&param2[]=0` ã€‚

### The Second Easy Md5 Challenge

```php+HTML
if($_POST['param1']!==$_POST['param2'] && md5($_POST['param1'])===md5($_POST['param2'])){
		die("success!");
	}
```

å¯ç”¨PHPæ•°ç»„ç»•è¿‡ã€‚post `param1[]=&param2[]=0` ã€‚

### Md5 Revenge Now!

```php+HTML
if((string)$_POST['param1']!==(string)$_POST['param2'] && md5($_POST['param1'])===md5($_POST['param2'])){
die("success!);
}
```

ç»•ä¸è¿‡å»ï¼Œä½†æ˜¯å› ä¸ºå“ˆå¸Œæ˜¯ä»æ— é™é›†åˆ°æœ‰é™é›†çš„æ˜ å°„ï¼Œå¿…ç„¶å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„æ¶ˆæ¯æ‹¥æœ‰ç›¸åŒçš„å“ˆå¸Œå€¼ï¼Œè€Œä¸”è¿™ç§æ¶ˆæ¯å¯¹å·²ç»å¯ä»¥è¢«æ„é€ äº†ã€‚ï¼ˆå·¥å…·ï¼š https://xz.aliyun.com/t/2232 ï¼‰

https://crypto.stackexchange.com/questions/1434/are-there-two-known-strings-which-have-the-same-md5-hash-value

```python
s1="4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2"
s2="4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2"
y=lambda s: "%"+"%".join([s[i*2:i*2+2] for i in range(len(s)/2)])
print y(s1)
print y(s2)
```

```php
<?php 
$param1=urldecode("%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2");
$param2=urldecode("%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2");
print md5($param1)."\n";
print md5($param2)."\n";
print md5($param1)===md5($param2);
print "\n";
 ?>
//008ee33a9d58b51cfeb425b0959121c9
//008ee33a9d58b51cfeb425b0959121c9
//1
```

![1522986666339](1522986666339.png)

# é™„ä»¶

- [Welcome](QWB_18h2f8018b2749786138460y893uy3gqf894n7xc891754) 

- [streamgame1](StreamGame1_zip_1y829eyn1723891s827h3 -.zip) 

- [streamgame2](StreamGame2_zip_12983yrbhsauibf1o8374tybchsd21.zip)

- [streamgame3](StreamGame3_0) 

- [streamgame4](StreamGame4_zip_fjh382901fu3n8.zip) 

# é¢˜ç›®å¤‡ä»½

https://github.com/jas502n/2018-QWB-CTF  

stream

# å¥‡æ€ªçš„å¿ƒè·¯~

***streamgame3.py***

```python
from flag import flag
assert flag.startswith("flag{")
assert flag.endswith("}")
assert len(flag)==24
# flagå…±24ä¸ªå­—ç¬¦ï¼Œå½¢å¦‚ /flag{.{18}}/
# ä¸­é—´18ä¸ªå­—ç¬¦å°±æ˜¯æˆ‘ä»¬æƒ³å¯»æ‰¾çš„lfsråˆå§‹çŠ¶æ€

def lfsr(R,mask):
    """å®šä¹‰äº†ä¸€ä¸ªlfsrçš„çŠ¶æ€å˜åŒ–è§„åˆ™
    è¾“å…¥æ˜¯å¯„å­˜å™¨å½“å‰å­˜å‚¨çš„çŠ¶æ€ä¿¡æ¯å’Œä¸€ä¸ªæ©ç ï¼Œ
    ä¸¤è€…ç»è¿‡ä¸€å®šè¿ç®—å¾—åˆ°å¯„å­˜å™¨ä¸‹ä¸€ä¸ªçŠ¶æ€å¹¶è¾“å‡º
    """
    output = (R << 1) & 0xffffff 
    #å°†å½“å‰å€¼å·¦ç§»ä¸€ä½ï¼Œå¹¶èˆå¼ƒè¶…å‡º 24bit çš„éƒ¨åˆ†
    #è¿™å°±æ˜¯çº¿æ€§åé¦ˆç§»ä½å¯„å­˜å™¨çš„ `ç§»ä½` éƒ¨åˆ†
    #å¯ä»¥ç†è§£ä¸º output = (R * 2) % 0xffffff
    i=(R&mask)&0xffffff
    #å°†å½“å‰å€¼å’Œæ©ç æŒ‰ä½ä¸ï¼Œåªä½¿ç”¨æŸäº›å›ºå®šä½çš„ä¿¡æ¯
    #å¦‚å¯¹äº R3_mask=0x100002 ï¼Œåªä½¿ç”¨å½“å‰å€¼å·¦èµ·ç¬¬å››ä½å’Œå³èµ·ç¬¬äºŒä½
    #å¯¹æ¯”çº¿æ€§å‡½æ•°çš„å®šä¹‰ï¼Œå‘ç°0x100002çš„æ¯ä¸€ä½å¯¹åº”çš„å°±æ˜¯fä¸­çš„a1,a2,...,a24ï¼Œ
    #å…¶ä¸­a4=a23=1,a1=a2=a3=a5=...=a22=a24=0
    #è€ŒRçš„æ¯ä¸€ä½å¯¹åº”çš„æ˜¯b1,b2,...b24
    #é‚£ä¹ˆ `R&mask` å°±å°†fä¸­ç”¨äºå¼‚æˆ–çš„æ¯ä¸€é¡¹éƒ½æ±‚å‡ºæ¥å¹¶ä¿å­˜åœ¨içš„æ¯ä¸€ä½ä¸­
    #ï¼ˆæˆ‘è®¤ä¸º `&0xffffff` æ˜¯å¤šä½™çš„ï¼ŒRå’Œmaskéƒ½æ€»åœ¨24ä½ä»¥å†…ï¼‰
    lastbit=0
    # lastbitå®é™…ä¸Šæ˜¯å‡½æ•°ä¸­çš„a0
    while i!=0:
        lastbit^=(i&1) 
        i=i>>1
    # è¿™ä¸ªå¾ªç¯ç”¨äºå–å‡ºiä¸­çš„æ¯ä¸€ä½å¹¶å®Œæˆå¼‚æˆ–æ“ä½œï¼Œiä¸­æœ‰å¥‡æ•°ä¸ª1åˆ™lastbitä¸º1ï¼Œåä¹‹ä¸º0
    # å¾—åˆ°çš„lastbitå°±æ˜¯ã€å¯„å­˜å™¨å½“å‰çŠ¶æ€çš„çº¿æ€§å‡½æ•°ã€‘fçš„å‡½æ•°å€¼
    # lastbitå°±æ˜¯æ‰€è°“çš„ `çº¿æ€§åé¦ˆ` ï¼Œå®ƒä¸å¯„å­˜å™¨å½“å‰çŠ¶æ€çº¿æ€§ç›¸å…³ï¼Œ
    # å¹¶ä½œä¸ºè¾“å…¥ä½ï¼Œç”¨ä»¥äº§ç”Ÿå¯„å­˜å™¨çš„ä¸‹ä¸€ä¸ªçŠ¶æ€
    output^=lastbit
    # äº§ç”Ÿå¯„å­˜å™¨çš„ä¸‹ä¸€ä¸ªçŠ¶æ€
    return (output,lastbit)

def single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask):
    """å®Œæˆä¸‰ä¸ªçº¿æ€§åé¦ˆç§»ä½å¯„å­˜å™¨çš„ä¸€æ¬¡çŠ¶æ€å˜æ¢
    å¹¶å°†ä¸‰ä¸ªåé¦ˆè¿›è¡Œç®€å•è¿ç®—ï¼ˆx1x2 ^ x2'x3ï¼‰åè¿”å›
    
    --ã€æˆ‘ç°åœ¨æ˜ç™½è¿‡æ¥äº†ï¼Œæˆ‘åœ¨
    http://findneo.github.io/180325QWBWP/#streamgame3
    ä¸­æåˆ°çš„ä¸€ä¸ªå¤±è´¥çš„å°è¯•ä¸ºä»€ä¹ˆä¼šå¤±è´¥ï¼Œï¼šï¼‰
    å°±æ˜¯å› ä¸ºæœ€åæ–‡ä»¶ä¸­ä¿å­˜çš„æ¯ä¸ªbitéƒ½åªæ˜¯è¿™ä¸ªç®€å•è¿ç®—çš„ç»“æœ
    è€Œè¿™ä¸ªç®€å•çš„è¿ç®—å¯¼è‡´äº†æ¯ä¸ªsingle_roundä¸­åé¦ˆçš„ä¿¡æ¯
    ä»3ä¸ªbité™åˆ°äº†1ä¸ªbitã€‘--
    """
    (R1_NEW,x1)=lfsr(R1,R1_mask)
    (R2_NEW,x2)=lfsr(R2,R2_mask)
    (R3_NEW,x3)=lfsr(R3,R3_mask)
    return (R1_NEW,R2_NEW,R3_NEW,(x1*x2)^((x2^1)*x3))

R1=int(flag[5:11],16)
R2=int(flag[11:17],16)
R3=int(flag[17:23],16)
assert len(bin(R1)[2:])==17
assert len(bin(R2)[2:])==19
assert len(bin(R3)[2:])==21
R1_mask=0x10020
R2_mask=0x4100c
R3_mask=0x100002


for fi in range(1024):
    print fi
    tmp1mb=""
    for i in range(1024):
        tmp1kb=""
        for j in range(1024):
            tmp=0
            for k in range(8):
                (R1,R2,R3,out)=single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask)
                tmp = (tmp << 1) ^ out
            tmp1kb+=chr(tmp)
        tmp1mb+=tmp1kb
    f = open("./output/" + str(fi), "ab")
    f.write(tmp1mb)
    f.close()
```

***solution***

å› ä¸ºæŠ½å¤´è¾ƒå°‘ï¼Œæ‰€ä»¥ç”Ÿæˆåºåˆ—çš„æ¯ä¸€ä½éƒ½åªå’Œåˆå§‹çŠ¶æ€çš„å°‘æ•°å‡ ä½æœ‰å…³ï¼Œå¦‚æœæ¯ä¸€è½®åˆ†å¼€è€ƒè™‘ï¼Œå†æ‰‹åŠ¨åˆå¹¶åˆå§‹çŠ¶æ€ï¼Œéå†é›†åˆä¼šå°éå¸¸å¤šã€‚æŠ˜è…¾äº†å¾ˆä¹…æ‰å‘ç°è‡ªå·±è¦å†™çš„æ˜¯é€’å½’ï¼Œå†™äº†å¾ˆå¤šä»£ç ä½†æ˜¯ä¸workğŸ¤”ï¼Œåˆ°æ¯”èµ›æœ€åä¹Ÿæ²¡è°ƒå‡ºæ¥ã€‚

èµ›åæ€»ç®—æŒ‰æˆ‘çš„æ„æ„¿è·‘èµ·æ¥äº†ï¼Œä½†æ˜¯é©¬ä¸Šå‘ç°è‡ªå·±å¤ªå¤©çœŸï¼Œè¿™ä»£ç å°±æ˜¯è·‘åˆ°çˆ†æ ˆä¹Ÿæ²¡åŠæ³•å¾—åˆ°ç»“æœï¼Œçœ‹æ¥è¿˜æ˜¯è¦è®¤çœŸç†è§£åŸç†ï¼Œä»ç®—æ³•ä¸Šçªç ´ï¼Œæš´åŠ› x ä¸å¯å–ã€‚ä¸‹é¢æ˜¯æˆ‘å·²è¢«è¯æ˜ä¸å¯å–çš„æƒ³æ³•ï¼ˆæˆ‘å±…ç„¶åœ¨è¯•å›¾æ”»ç ´å®‰å…¨é«˜æ•ˆçš„ä¼ªéšæœºåºåˆ—å‘ç”Ÿå™¨ï¼ŒçœŸæ˜¯naiveå•Šï¼‰ï¼š

```python
#coding:utf8
import itertools
# å› ä¸ºæ©ç çš„åŸå› ï¼Œå¤§å¤§é™ä½äº†è®¡ç®—çš„å¤æ‚åº¦ã€‚æˆ‘ä»¬å¯ä»¥åœ¨æ¯æ¬¡è§„çº¦è¿ç®—æ—¶åªéå†å½±å“ç»“æœçš„ä½ï¼Œè€Œå¿½ç•¥å…¶ä»–å°†è¢«æ©ç å¿½ç•¥çš„ä½ã€‚
# è¿™æ ·å®é™…ä¸Šå¤æ‚åº¦ä»æ¯ä¸€æ¬¡è§„çº¦éƒ½æœ‰2**ï¼ˆ17+19+21ï¼‰=2**57çº¦10**18ç§å¯èƒ½é™ä½åˆ°äº†æ¯ä¸€ä½çº¦å¤§æ¦‚2**8ç§å¯èƒ½ï¼
# å¯¹æˆ‘æ¥è¯´ï¼Œç¼–ç¨‹å®ç°çš„éš¾ç‚¹åœ¨äºå¦‚ä½•æ§åˆ¶åªéå†å½±å“ç»“æœçš„ä½ï¼Œä¸€ç§æ˜¯åœ¨åŸæ¥çš„åŸºç¡€ä¸ŠåŠ ä¸€ä¸ªåˆ¤æ–­ï¼Œåˆ¤æ–­æ˜¯å¦è¯¥æƒ…å†µå·²è¢«è€ƒè™‘ï¼Œè¿™åº”è¯¥ä¸åˆé€‚ã€‚
# å¦ä¸€ç§å°±æ˜¯ç”¨ä¸€ä¸ªlistè£…Rçš„æ¯ä¸€ä½
# å†æœ‰å°±æ˜¯æ‰‹åŠ¨ç»„åˆä¸‰ä¸ªéƒ¨åˆ†çš„æ¯æ¬¡åé¦ˆ
def lfsr(R,mask):
    output = (R << 1) & 0xffffff
    i=(R&mask)&0xffffff
    lastbit=0
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)
def single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask): 
    (R1_NEW,x1)=lfsr(R1,R1_mask)
    (R2_NEW,x2)=lfsr(R2,R2_mask)
    (R3_NEW,x3)=lfsr(R3,R3_mask)
    return (R1_NEW,R2_NEW,R3_NEW,(x1*x2)^((x2^1)*x3)) # lastbit=(R.count(1)%2?1:0)  R*å³è¾¹åŠ ä¸€ä½lastbit

# R1sm means R1_sub_mask
R1_mask=0x10020;R1sm=[];R1sm.extend([0x10000,0x20])
R2_mask=0x4100c;R2sm=[];R2sm.extend([0x40000,0x1000,0x8,0x4])
R3_mask=0x100002;R3sm=[];R3sm.extend([0x100000,0x2])

def genAll(Rsm):
    # å…¨ç»„åˆ
    all_iter=[itertools.combinations(Rsm,num) for num in xrange(len(Rsm)+1)]
    return itertools.chain.from_iterable(all_iter)

def genBit(sub_mask,seq,mask):
    ret=0
    for i in sub_mask:
        ret|=i
    done=mask
    if seq==0:done=0
    else:
        for i in range(seq):
            done|=(mask>>i)
    ret&=(done^0xffffff)&(0xffffff<<seq)
    return ret

def digui(level,R1,R2,R3):
    if level==996:
        print hex(R1),hex(R2),hex(R3)
        return 0
    for g,h,n in itertools.product(genAll(R1sm),genAll(R2sm),genAll(R3sm)):
        R1|=genBit(g,level,R1_mask)
        R2|=genBit(h,level,R2_mask)
        R3|=genBit(n,level,R3_mask)
        (R1,R2,R3,out)=single_round(R1,R1_mask,R2,R2_mask,R3,R3_mask)
        if out==((ord(f[level/8])>>(7-(level%8)))&0x1):
            digui(level+1,R1,R2,R3)

f=open("output/0").read()
digui(0,0,0,0)
```

æ®è¯´æ˜¯è€ƒå¯Ÿå¿«é€Ÿç›¸å…³æ”»å‡»ï¼Œä¸WHCTFä¸€é¢˜ç›¸ä¼¼ï¼Œåœ¨ https://www.xctf.org.cn/library/details/whctf-writeup/ æœç´¢Bornpigå³å¯çœ‹åˆ°ç›¸å…³ä¿¡æ¯ã€‚

æˆ‘è¿˜æ‰¾åˆ°ä¸€äº›ç›¸å…³ä¿¡æ¯ï¼Œä½†æš‚æ—¶æ²¡æœ‰æ—¶é—´æ·±å…¥è§£å†³ã€‚

- [å¿«é€Ÿç›¸å…³æ”»å‡»æŠ¥å‘Š](https://download.csdn.net/download/weixin_38627405/10033503)
- [å…³äºçº¿æ€§ç§»ä½å¯„å­˜å™¨å’Œå¿«é€Ÿç›¸å…³æ”»å‡»ä¸­çš„ç®—æ³•Aå’Œç®—æ³•Bè¯¦ç»†åˆ†æè§£ç­”](https://www.jianshu.com/p/7bb9c0d057be)
- [çº¿æ€§åé¦ˆç§»ä½å¯„å­˜å™¨ä¸æ¢…æ£®æ—‹è½¬ç®—æ³•](https://blog.csdn.net/ACdreamers/article/details/44656743)
- [æµå¯†ç å¿«é€Ÿç›¸å…³æ”»å‡»ç»¼è¿°](http://zzs.ujs.edu.cn/xbzkb/CN/article/downloadArticleFile.do?attachType=PDF&id=1440)

å»äº†è§£äº†ä¸€ä¸‹çº¿æ€§åé¦ˆç§»ä½å¯„å­˜å™¨ï¼Œç†è§£ä¸€äº›æ¦‚å¿µï¼Œå¯¹ä»£ç åšäº†äº›æ³¨é‡Šã€‚

- In [electronics](https://en.wikipedia.org/wiki/Electronics), a **flip-flop** or **latch** is a [circuit](https://en.wikipedia.org/wiki/Electronic_circuit) that has two stable states and can be used to store state information. 
  flip-flopï¼ˆè§¦å‘å™¨ï¼‰æˆ–latchï¼ˆé”å­˜å™¨ï¼‰éƒ½æ˜¯æŸç§ç”µè·¯ï¼Œéƒ½æ ¹æ®è¾“å…¥æ”¹å˜å­˜å‚¨çš„çŠ¶æ€ä¿¡æ¯ï¼ŒåŒºåˆ«æ˜¯å‰è€…å½“æ—¶é’Ÿæœ‰æ•ˆæ—¶æ”¹å˜æ‰å‘ç”Ÿï¼Œä¹Ÿå°±æ˜¯åŒæ­¥çš„ï¼Œåè€…æ˜¯æ—¶é’Ÿæ— å…³çš„ï¼Œä¹Ÿå°±æ˜¯å¼‚æ­¥çš„ã€‚
- a **shift register** is a cascade of [flip flops](https://en.wikipedia.org/wiki/Flip-flop_(electronics)) ã€‚
  ç§»ä½å¯„å­˜å™¨æ˜¯è§¦å‘å™¨çš„çº§è”ã€‚
- In [computing](https://en.wikipedia.org/wiki/Computing), a **linear-feedback shift register** (LFSR) is a [shift register](https://en.wikipedia.org/wiki/Shift_register) whose input bit is a [linear function](https://en.wikipedia.org/wiki/Linear#Boolean_functions) of its previous state.  
  çº¿æ€§åé¦ˆç§»ä½å¯„å­˜å™¨æ˜¯ä¸€ä¸ªç§»ä½å¯„å­˜å™¨ï¼Œå®ƒçš„è¾“å…¥ä½æ˜¯å®ƒå…ˆå‰çŠ¶æ€çš„çº¿æ€§å‡½æ•°ã€‚
- çº¿æ€§æŒ‡çš„æ˜¯é½æ¬¡æ€§ï¼ˆ`f(Î±x) = Î±f(x) for all Î±`ï¼‰å’Œå¯åŠ æ€§ï¼ˆ` f(x + y) = f(x) + f(y)`ï¼‰ï¼Œä¸¤è€…åœ¨æœ‰ç†æ•°åŸŸæ˜¯ç­‰ä»·çš„ã€‚ä¸Šè¿°å®šä¹‰ä¸­çš„çº¿æ€§å‡½æ•°å®é™…ä¸ŠæŒ‡çš„æ˜¯å¸ƒå°”ä»£æ•°ä¸­çš„çº¿æ€§å‡½æ•°ï¼Œå½¢å¼ä¸Šè¿™æ ·è¡¨è¿°ï¼š
  å¯¹äº![1536909203599](1536909203599.png) ï¼Œå­˜åœ¨ ![1536909278873](1536909278873.png) ï¼Œä½¿å¾—![1536909303104](1536909303104.png)ï¼Œé‚£ä¹ˆ`f` æ˜¯ä¸€ä¸ªçº¿æ€§å‡½æ•°ã€‚ï¼ˆå…¶ä¸­çš„ç¬¦å·åˆ†åˆ«è¡¨ç¤º`é€»è¾‘å¼‚æˆ–`å’Œ`é€»è¾‘ä¸` ï¼Œè¯¦æƒ…å¦‚ä¸‹å›¾ï¼‰

![52229954019](./)

~~æœ‰ä¸€ä½æœ‹å‹åœ¨[è¿™ç¯‡æ–‡ç« ](http://blog.kyrios.cn/2018/03/29/2018-qwb-cnss-wp/#s3)æåˆ°ä¸€ç§åŸºäº`outbit=(x1*x2)^((x2^1)*x3)` ä»è€Œå½“`x1==x3` æ—¶`x1==outbit` æ¥ç•¥è¿‡R2è€Œåªçˆ†ç ´R1å’ŒR3çš„åšæ³•ï¼Œæˆ‘å®ç°äº†ä¸€ä¸‹ï¼Œæ„Ÿè§‰å¤æ‚åº¦ä»ç„¶ä¸å¯æ¥å—ã€‚~~~~

```python
def lfsr(R,mask):
    output = (R << 1) & 0xffffff
    i=(R&mask)&0xffffff
    lastbit=0
    while i!=0:
        lastbit^=(i&1)
        i=i>>1
    output^=lastbit
    return (output,lastbit)

R1_mask=0x10020
R2_mask=0x4100c
R3_mask=0x100002

import time
s=''.join([bin(ord(i))[2].zfill(8) for i in open("output/0","rb").read()])
def handle1(start,step):
    for i in xrange(start,start+step):
        for j in xrange(2**20,2**21):
            R1,R3,flag=i,j,1
            for offset in xrange(len(s)):
                R1,out1=lfsr(R1,R1_mask)
                R3,out3=lfsr(R3,R3_mask)
                if out1==out3 and out1!=s[offset]:
                    flag=0
                    break
            if flag:
                print "flag{%s******%s}"%(bin(i)[2:],bin(j)[2:])
                print time.asctime()
                exit(0)
        if (i-start)%10==0:
            print start,time.asctime(),"#"
handle1(2**16,2**16)
```

~~å—ä»–å¯å‘ï¼Œæˆ‘æœ‰äº†ä¸ªåŸºäº`outbit==(x2==1?x1:x3)` çˆ†ç ´çš„æƒ³æ³•ï¼Œä½†çœ‹èµ·æ¥ä¹Ÿä¸å¯æ“ä½œã€‚~~

~~æŠ•å…¥å¤ªå¤šæ—¶é—´äº†ï¼Œè¿˜æ˜¯ç­‰å®˜æ–¹WPå§ï¼šï¼‰~~